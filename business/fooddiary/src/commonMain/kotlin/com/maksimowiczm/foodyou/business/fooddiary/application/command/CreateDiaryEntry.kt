package com.maksimowiczm.foodyou.business.fooddiary.application.command

import com.maksimowiczm.foodyou.business.fooddiary.domain.DiaryEntry
import com.maksimowiczm.foodyou.business.fooddiary.domain.DiaryFood
import com.maksimowiczm.foodyou.business.fooddiary.infrastructure.persistence.LocalDiaryEntryDataSource
import com.maksimowiczm.foodyou.business.fooddiary.infrastructure.persistence.LocalMealDataSource
import com.maksimowiczm.foodyou.business.shared.domain.error.ErrorLoggingUtils
import com.maksimowiczm.foodyou.shared.common.date.now
import com.maksimowiczm.foodyou.shared.common.domain.infrastructure.command.Command
import com.maksimowiczm.foodyou.shared.common.domain.infrastructure.command.CommandHandler
import com.maksimowiczm.foodyou.shared.common.domain.measurement.Measurement
import com.maksimowiczm.foodyou.shared.common.domain.result.Ok
import com.maksimowiczm.foodyou.shared.common.domain.result.Result
import kotlin.reflect.KClass
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.datetime.LocalDate
import kotlinx.datetime.LocalDateTime

data class CreateDiaryEntryCommand(
    val measurement: Measurement,
    val mealId: Long,
    val date: LocalDate,
    val food: DiaryFood,
) : Command

sealed interface CreateDiaryEntryError {
    data object MealNotFound : CreateDiaryEntryError

    data object Unknown : CreateDiaryEntryError
}

internal class CreateDiaryEntryCommandHandler(
    private val diaryEntryDataSource: LocalDiaryEntryDataSource,
    private val mealDataSource: LocalMealDataSource,
) : CommandHandler<CreateDiaryEntryCommand, Long, CreateDiaryEntryError> {
    override val commandType: KClass<CreateDiaryEntryCommand> = CreateDiaryEntryCommand::class

    override suspend fun handle(
        command: CreateDiaryEntryCommand
    ): Result<Long, CreateDiaryEntryError> {

        val mealId = command.mealId
        val meal = mealDataSource.observeMealById(mealId).firstOrNull()

        if (meal == null) {
            return ErrorLoggingUtils.logAndReturnFailure(
                tag = TAG,
                throwable = null,
                error = CreateDiaryEntryError.MealNotFound,
                message = { "Meal with ID $mealId not found" },
            )
        }

        val entry = command.toDiaryEntry()

        return try {
            Ok(diaryEntryDataSource.insert(entry))
        } catch (e: CancellationException) {
            throw e
        } catch (e: Exception) {
            return ErrorLoggingUtils.logAndReturnFailure(
                tag = TAG,
                throwable = e,
                error = CreateDiaryEntryError.Unknown,
                message = { "Failed to create diary entry for food" },
            )
        }
    }

    private companion object {
        private const val TAG = "CreateDiaryEntryCommandHandler"
    }
}

private fun CreateDiaryEntryCommand.toDiaryEntry(): DiaryEntry =
    DiaryEntry(
        id = 0, // ID will be generated by the data source
        mealId = mealId,
        date = date,
        measurement = measurement,
        food = food,
        createdAt = LocalDateTime.now(),
    )
